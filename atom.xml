<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KR</title>
  
  <subtitle>随心所欲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://umlink.github.io/"/>
  <updated>2021-04-13T12:28:58.075Z</updated>
  <id>https://umlink.github.io/</id>
  
  <author>
    <name>umlink</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="https://umlink.github.io/2021/04/13/repeat-str-len/"/>
    <id>https://umlink.github.io/2021/04/13/repeat-str-len/</id>
    <published>2021-04-13T12:22:53.000Z</published>
    <updated>2021-04-13T12:28:58.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。"><a href="#给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。" class="headerlink" title="给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。"></a>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</h3><blockquote><p>来源：力扣（LeetCode）<br><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p></blockquote><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s = “”<br>输出: 0 </p><p>提示：</p><p>0 &lt;= s.length &lt;= 5 * 104<br>s 由英文字母、数字、符号和空格组成</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLongestSubstring = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> singleStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> subIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> strLen = str.length</span><br><span class="line">  <span class="comment">// 若剩余字符长度小于已有最大非重复自串长度直接 return</span></span><br><span class="line">  <span class="keyword">if</span> (strLen &lt; maxLen) <span class="keyword">return</span> maxLen</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (subIndex &lt; str.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> tempStr = str.substring(subIndex, strLen)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> tempStr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (singleStr.indexOf(s) === -<span class="number">1</span>) &#123;</span><br><span class="line">        singleStr += s</span><br><span class="line">        maxLen = singleStr.length &gt; maxLen ? singleStr.length : maxLen</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subIndex++</span><br><span class="line">        singleStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。&quot;&gt;&lt;a href=&quot;#给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。&quot; class=&quot;headerlink&quot; title=&quot;给定一个字符串，请你找出其中不含有重复字符的 最长子串 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://umlink.github.io/categories/LeetCode/"/>
    
    
      <category term="算法" scheme="https://umlink.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器 http 状态码及说明</title>
    <link href="https://umlink.github.io/2021/04/12/http-code/"/>
    <id>https://umlink.github.io/2021/04/12/http-code/</id>
    <published>2021-04-12T07:42:30.000Z</published>
    <updated>2021-04-12T09:07:32.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、信息响应"><a href="#一、信息响应" class="headerlink" title="一、信息响应"></a>一、信息响应</h3><table><thead><tr><th>Code</th><th>Concept</th><th>Explain</th></tr></thead><tbody><tr><td>100</td><td>continue</td><td>临时响应，表明迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</td></tr><tr><td>101</td><td>Switching Protocol</td><td>响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。（如websocket 协议升级[切换]）</td></tr><tr><td>102</td><td>Processing (WebDAV)</td><td>示服务器已收到并正在处理该请求，但没有响应可用</td></tr><tr><td>103</td><td>Early Hints</td><td>用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。</td></tr></tbody></table><h3 id="二、成功响应"><a href="#二、成功响应" class="headerlink" title="二、成功响应"></a>二、成功响应</h3><table><thead><tr><th>Code</th><th>Concept</th><th>Explain</th></tr></thead><tbody><tr><td>200</td><td>ok</td><td>表明请求已经成功（PUT 和 DELETE 的请求成功通常并不是响应200 OK的状态码而是 204 No Content 表示无内容(或者  201  Created表示一个资源首次被创建成功)。）</td></tr><tr><td>201</td><td>Created</td><td>该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应</td></tr><tr><td>202</td><td>Accepted</td><td>请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td>204</td><td>Not Content</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>Rest Content</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>Partial Content</td><td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。</td></tr><tr><td>207</td><td>Multi-Status (WebDAV)</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>208</td><td>Multi-Status (WebDAV)</td><td>在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。（em…）</td></tr><tr><td>226</td><td>IM Used (HTTP Delta encoding)</td><td>服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。</td></tr></tbody></table><h3 id="三、重定向"><a href="#三、重定向" class="headerlink" title="三、重定向"></a>三、重定向</h3><table><thead><tr><th>Code</th><th>Concept</th><th>Explain</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choice</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。（永久成定向）</td></tr><tr><td>302</td><td>Found</td><td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。（临时重定向）</td></tr><tr><td>303</td><td>See Other</td><td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。</td></tr><tr><td>304</td><td>Not Modified</td><td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</td></tr><tr><td>305</td><td>Use Proxy</td><td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</td></tr><tr><td>306</td><td>unused</td><td>在最新版的规范中，306 状态码已经不再被使用。</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。</td></tr></tbody></table><h3 id="四、客户端响应"><a href="#四、客户端响应" class="headerlink" title="四、客户端响应"></a>四、客户端响应</h3><table><thead><tr><th>Code</th><th>Concept</th><th>Explain</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</td></tr><tr><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</td></tr><tr><td>402</td><td>Payment Required</td><td>此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>Not Found</td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>Not Acceptable</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>Conflict</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</td></tr><tr><td>410</td><td>Gone</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。</td></tr><tr><td>411</td><td>Length Required</td><td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>Precondition Failed</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>Payload Too Large</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>URI Too Long</td><td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。</td></tr><tr><td>417</td><td>Expectation Failed</td><td>此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。</td></tr><tr><td>418</td><td>I’m a teapot</td><td>服务器拒绝尝试用 “茶壶冲泡咖啡”。</td></tr><tr><td>421</td><td>Misdirected Request</td><td>该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。</td></tr><tr><td>422</td><td>Unprocessable Entity (WebDAV)</td><td>请求格式良好，但由于语义错误而无法遵循。</td></tr><tr><td>423</td><td>Locked (WebDAV)</td><td>正在访问的资源被锁定。</td></tr><tr><td>424</td><td>Failed Dependency (WebDAV)</td><td>由于先前的请求失败，所以此次请求失败。</td></tr><tr><td>425</td><td>Too Early</td><td>服务器不愿意冒着风险去处理可能重播的请求。</td></tr><tr><td>426</td><td>Upgrade Required</td><td>服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade 头以指示所需的协议。</td></tr><tr><td>428</td><td>Precondition Required</td><td>原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。</td></tr><tr><td>429</td><td>Too Many Requests</td><td>用户在给定的时间内发送了太多请求（“限制请求速率”）。</td></tr><tr><td>431</td><td>Request Header Fields Too Large</td><td>服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。</td></tr><tr><td>451</td><td>Unavailable For Legal Reasons</td><td>用户请求非法资源，例如：由政府审查的网页。</td></tr></tbody></table><h3 id="五、服务端响应"><a href="#五、服务端响应" class="headerlink" title="五、服务端响应"></a>五、服务端响应</h3><table><thead><tr><th>Code</th><th>Concept</th><th>Explain</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器遇到了不知道如何处理的情况。</td></tr><tr><td>501</td><td>Not Implemented</td><td>此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。</td></tr><tr><td>502</td><td>Bad Gateway</td><td>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>当服务器作为网关，不能及时得到响应时返回此错误代码。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持请求中所使用的HTTP协议版本。</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。</td></tr><tr><td>508</td><td>Loop Detected (WebDAV)</td><td>服务器在处理请求时检测到无限循环。</td></tr><tr><td>510</td><td>Not Extended</td><td>客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。</td></tr><tr><td>511</td><td>Network Authentication Required</td><td>状态码指示客户端需要进行身份验证才能获得网络访问权限。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、信息响应&quot;&gt;&lt;a href=&quot;#一、信息响应&quot; class=&quot;headerlink&quot; title=&quot;一、信息响应&quot;&gt;&lt;/a&gt;一、信息响应&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;th&gt;Concept&lt;/th&gt;
&lt;th&gt;E
      
    
    </summary>
    
    
      <category term="浏览器" scheme="https://umlink.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>如何查看服务端日志?</title>
    <link href="https://umlink.github.io/2021/03/30/view-log/"/>
    <id>https://umlink.github.io/2021/03/30/view-log/</id>
    <published>2021-03-30T01:59:41.000Z</published>
    <updated>2021-03-30T02:48:54.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、直接查看文件内容"><a href="#一、直接查看文件内容" class="headerlink" title="一、直接查看文件内容"></a>一、直接查看文件内容</h2><blockquote><p>cat [-AbEnTv]</p></blockquote><h3 id="选项与参数"><a href="#选项与参数" class="headerlink" title="选项与参数"></a>选项与参数</h3><p>  -A ：相当于-vET的整合， 课列出一些特殊字符而不是空白而已<br>  -b ：列出行号，进针对非空白行做行号显示，空白行不会标记<br>  -E ：将结尾换行符$显示出来<br>  -n ：打印出行号，连同空白行也会有行号，与-b的选项不同<br>  -T :  将[tab]键以^I显示出来<br>  -v :  列出一些看不出来的特殊字符</p><blockquote><p>tac（和cat打印顺序相反）</p></blockquote><h2 id="二、翻页查看"><a href="#二、翻页查看" class="headerlink" title="二、翻页查看"></a>二、翻页查看</h2><blockquote><p>less less可前后翻页，不止向上查找，也可向下查找</p></blockquote><h3 id="按键-命令"><a href="#按键-命令" class="headerlink" title="按键/命令"></a>按键/命令</h3><p> [pagedown] ：向下翻页<br> [pageup] ：向上翻页<br> /字符串：在当前显示的内容（翻页进度位置），向下查找这个字符串关键字<br> ?字符串：向上查找字符串<br> n ：重复前一个查找，与/或?有关， 比如前一个命令是？表示向上查找，此时n会向上查找<br> N ：反向的重复前一个查找<br> g ：跳转到当前文件数据的第一行<br> G ：跳转到当前文件数据的最后一行<br> q ：退出当前文件的浏览</p><h2 id="三、数据截取"><a href="#三、数据截取" class="headerlink" title="三、数据截取"></a>三、数据截取</h2><blockquote><p>head</p></blockquote><p>head命令用来提取文件的前n行，一般配合使用-n选项。当指定的行数为负数-x时，则会打印出除了后面x行的其他所有数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 10 error.log</span><br></pre></td></tr></table></figure><blockquote><p>tail</p></blockquote><p>从文件尾部截取数据。tail也是工作中最常用的命令，因为可以利用-f选项，一直刷新获取文件尾部最新数据。</p><h3 id="选项与参数-1"><a href="#选项与参数-1" class="headerlink" title="选项与参数"></a>选项与参数</h3><p> -n : 查看后n行数据，注意当n后面值带“+”号表示从第x行开始， 如 tail -n +1000 test.txt<br> -f : 展示文件后面</p><h2 id="四、筛选日志"><a href="#四、筛选日志" class="headerlink" title="四、筛选日志"></a>四、筛选日志</h2><blockquote><p>grep</p></blockquote><p>example：查看文件包含 ‘hello’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat -n error.txt | grep &#39;hello&#39;</span><br><span class="line">tail -200f error.log | grep &#39;hello&#39;</span><br></pre></td></tr></table></figure><h2 id="五、其它"><a href="#五、其它" class="headerlink" title="五、其它"></a>五、其它</h2><blockquote><p><code>&gt;&gt;</code> : 文件追加重定向命令</p></blockquote><p>example：将 test.txt 的最后10行复制到hello.txt中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 test.txt &gt;&gt; hello.txt</span><br></pre></td></tr></table></figure><h2 id="六、组合使用示例"><a href="#六、组合使用示例" class="headerlink" title="六、组合使用示例"></a>六、组合使用示例</h2><p>example: 查看文件 10 ~ 20 行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head -n 20 text.txt | tail -n 10</span><br><span class="line"></span><br><span class="line">cat -n test.txt | head -n 20 | tail -n 10</span><br></pre></td></tr></table></figure><p>参考文献：<a href="https://juejin.cn/post/6844904069627133966">https://juejin.cn/post/6844904069627133966</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、直接查看文件内容&quot;&gt;&lt;a href=&quot;#一、直接查看文件内容&quot; class=&quot;headerlink&quot; title=&quot;一、直接查看文件内容&quot;&gt;&lt;/a&gt;一、直接查看文件内容&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;cat [-AbEnTv]&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://umlink.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="linux" scheme="https://umlink.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>webpack 优化思路</title>
    <link href="https://umlink.github.io/2021/03/25/opt-webpack/"/>
    <id>https://umlink.github.io/2021/03/25/opt-webpack/</id>
    <published>2021-03-25T02:01:34.000Z</published>
    <updated>2021-03-25T02:02:49.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><ul><li>webpack-bundle-analyzer：文件大小分析</li><li>speed-measure-webpack-plugin 打包耗时分析</li></ul><ol><li>使用高版本的 webpack 和 nodejs</li><li>按需引入</li><li>搜小查找范围（loader）<ul><li>exclude/include (确定 loader 规则范围)</li><li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li><li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li><li>resolve.extensions 尽可能减少后缀尝试的可能性</li><li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li><li>IgnorePlugin (完全排除模块)</li><li>合理使用alias</li></ul></li><li>缓存</li><li>多进程/多实例构建：HappyPack(不维护了)、thread-loader</li><li>代码压缩</li><li>图片压缩或外链（压缩）</li><li>样式分离 （mini-css-extract-plugin）</li><li>DLL 动态链接库</li><li> CommonsChunkPlugin =&gt; optimization.splitChunks 和 optimization.runtimeChunk</li><li>CommonsChunkPlugin<ol><li>公用包的抽离【react、lodash、moment、vue、vue-loaderK】</li></ol></li><li> optimization.splitChunks.chunks: “all”</li><li>当前模块是公共模块（多处引用）或者模块来自 node_modules </li><li>当前模块大小大于 30kb 如果此模块是按需加载，并行请求的最大数量小于等于 5 </li><li>如果此模块在初始页面加载，并行请求的最大数量小于等于 3</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;优化方向&quot;&gt;&lt;a href=&quot;#优化方向&quot; class=&quot;headerlink&quot; title=&quot;优化方向&quot;&gt;&lt;/a&gt;优化方向&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;webpack-bundle-analyzer：文件大小分析&lt;/li&gt;
&lt;li&gt;speed-measure-we
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://umlink.github.io/categories/webpack/"/>
    
    
      <category term="javascirpt" scheme="https://umlink.github.io/tags/javascirpt/"/>
    
      <category term="nodejs" scheme="https://umlink.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ajax-hooks</title>
    <link href="https://umlink.github.io/2021/03/25/ajax-hooks/"/>
    <id>https://umlink.github.io/2021/03/25/ajax-hooks/</id>
    <published>2021-03-25T01:58:25.000Z</published>
    <updated>2021-03-25T01:59:19.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一：new实例"><a href="#方法一：new实例" class="headerlink" title="方法一：new实例"></a>方法一：new实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyXHR</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">beforeHooks = &#123;&#125;, afterHooks = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.XHR = <span class="built_in">window</span>.XMLHttpRequest</span><br><span class="line">    <span class="built_in">this</span>.beforeHooks = beforeHooks</span><br><span class="line">    <span class="built_in">this</span>.afterHooks = afterHooks</span><br><span class="line">    <span class="built_in">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line">  init () &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">window</span>.XMLHttpRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>._xhr = <span class="keyword">new</span> _this.XHR()</span><br><span class="line">      _this.overWrite(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  overWrite (proxyXHR) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxyXHR._xhr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> proxyXHR._xhr[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.overwriteMethod(key, proxyXHR)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  overwriteMethod (key, proxyXHR) &#123;</span><br><span class="line">    <span class="keyword">let</span> beforeHooks = <span class="built_in">this</span>.beforeHooks</span><br><span class="line">    <span class="keyword">let</span> afterHooks = <span class="built_in">this</span>.afterHooks</span><br><span class="line">    proxyXHR[key] = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 前置钩子 可拦截</span></span><br><span class="line">      <span class="keyword">if</span> (beforeHooks[key] &amp;&amp; (beforeHooks[key].call(proxyXHR._xhr, args) === <span class="literal">false</span>)) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 执行原生方法</span></span><br><span class="line">      <span class="keyword">const</span> res = proxyXHR._xhr[key].apply(proxyXHR._xhr, args)</span><br><span class="line">      <span class="comment">// 后置钩子</span></span><br><span class="line">      afterHooks[key] &amp;&amp; afterHooks[key].call(proxyXHR._xhr, res)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> AnyXHR(&#123;</span><br><span class="line">  open: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;前置钩子执行&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;open&#x27;</span>, args)</span><br><span class="line">  &#125;,</span><br><span class="line">  onreadystatechange: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;onreadystatechange&#x27;</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  open: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;后置钩子执行&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="方法二：劫持原型"><a href="#方法二：劫持原型" class="headerlink" title="方法二：劫持原型"></a>方法二：劫持原型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajaxHooks = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params">hooks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      open = <span class="literal">null</span>,</span><br><span class="line">      send = <span class="literal">null</span></span><br><span class="line">    &#125; = hooks;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&#x27;undefined&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> _openPrototype = <span class="built_in">window</span>.XMLHttpRequest.prototype.open;</span><br><span class="line">    <span class="keyword">const</span> _sendPrototype = <span class="built_in">window</span>.XMLHttpRequest.prototype.send;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> openReplacement = <span class="function"><span class="keyword">function</span>(<span class="params">openHook, openPrototype</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">method, url, <span class="keyword">async</span>, user, password</span>) </span>&#123;</span><br><span class="line">        openHook.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> openPrototype.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getHookByProps = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">hooks[props] &amp;&amp; hooks[props].apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="built_in">this</span>[<span class="string">`_<span class="subst">$&#123;props&#125;</span>`</span>] &amp;&amp; <span class="built_in">this</span>[<span class="string">`_<span class="subst">$&#123;props&#125;</span>`</span>].apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sendReplacement = <span class="function"><span class="keyword">function</span>(<span class="params">sendHook, sendPrototype</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> onMappingKeyList = [</span><br><span class="line">          onreadystatechange,</span><br><span class="line">          onloadstart,</span><br><span class="line">          onloadend,</span><br><span class="line">          onerror,</span><br><span class="line">          ontimeout,</span><br><span class="line">          onabort</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        onMappingKeyList.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>[<span class="string">&#x27;_&#x27;</span> + key] = <span class="built_in">this</span>[key] ? <span class="built_in">this</span>[key] : <span class="literal">null</span>;</span><br><span class="line">          <span class="built_in">this</span>[key] = getHookByProps(key)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sendHook.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> sendPrototype.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.XMLHttpRequest.prototype.open = openReplacement(open, _openPrototype)</span><br><span class="line">    <span class="built_in">window</span>.XMLHttpRequest.prototype.send = sendReplacement(send, _sendPrototype)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ajaxHooks</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法一：new实例&quot;&gt;&lt;a href=&quot;#方法一：new实例&quot; class=&quot;headerlink&quot; title=&quot;方法一：new实例&quot;&gt;&lt;/a&gt;方法一：new实例&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="chrome" scheme="https://umlink.github.io/categories/chrome/"/>
    
    
      <category term="javascript" scheme="https://umlink.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>关于页面的平滑滚动</title>
    <link href="https://umlink.github.io/2021/03/25/smooth-scroll/"/>
    <id>https://umlink.github.io/2021/03/25/smooth-scroll/</id>
    <published>2021-03-25T01:54:43.000Z</published>
    <updated>2021-03-25T01:57:05.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-toTop"><a href="#1-toTop" class="headerlink" title="1. toTop"></a>1. toTop</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollToTop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">  <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(scrollToTop);</span><br><span class="line">    <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, c - c / <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scrollToTop();</span><br></pre></td></tr></table></figure><h2 id="2-to-指定位置"><a href="#2-to-指定位置" class="headerlink" title="2. to 指定位置"></a>2. to 指定位置</h2><pre><code class="javascript">const smoothScroll = element =&gt;  document.querySelector(element).scrollIntoView(&#123;    behavior: &#39;smooth&#39;  &#125;);smoothScroll(&#39;#fooBar&#39;); smoothScroll(&#39;.fooBar&#39;); </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-toTop&quot;&gt;&lt;a href=&quot;#1-toTop&quot; class=&quot;headerlink&quot; title=&quot;1. toTop&quot;&gt;&lt;/a&gt;1. toTop&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://umlink.github.io/categories/javascript/"/>
    
    
      <category term="chrome" scheme="https://umlink.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>浏览器拿到 html 到渲染成页面发生了什么？</title>
    <link href="https://umlink.github.io/2021/03/25/html-page/"/>
    <id>https://umlink.github.io/2021/03/25/html-page/</id>
    <published>2021-03-25T01:49:28.000Z</published>
    <updated>2021-03-25T01:52:57.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、从获得-Html-到页面渲染的全部流程"><a href="#一、从获得-Html-到页面渲染的全部流程" class="headerlink" title="一、从获得 Html 到页面渲染的全部流程"></a>一、从获得 Html 到页面渲染的全部流程</h3><h4 id="1-1-DOM-树构建"><a href="#1-1-DOM-树构建" class="headerlink" title="1.1 DOM 树构建"></a>1.1 DOM 树构建</h4><p>渲染器进程接受到的数据也就是 HTML。渲染器进程的核心任务就是把 html、css、js、image 等资源渲染成用户可以交互的 web 页面。渲染器进程的主线程将 html 进行解析，构造 DOM 数据结构。DOM 也就是文档对象模型，是浏览器对页面在其内部的表示形式，是 web 开发程序员可以通过 JS 与之交互的数据结构和 API。html 首先通过 tokeniser 标记化，通过词法分析将输入的 html 内容解析成多个标记，根据识别后的标记进行 DOM 树构造，在 DOM 树构建过程中会创建 document 对象，然后以 document 的为根节点的 DOM 树，不断进行修改，向其中添加各种元素。</p><h4 id="1-2-渲染阻塞"><a href="#1-2-渲染阻塞" class="headerlink" title="1.2 渲染阻塞"></a>1.2 渲染阻塞</h4><p>html 代码中往往会引入一些额外的资源，比如图片、CSS、JS 脚本等，图片和 CSS 这些资源需要通过网络下载或从缓存中直接加载，这些资源不会阻塞 html 的解析，因为他们不会影响 DOM 树的生成，但当 HTML 解析过程中遇到 script 标签，就会停止 html 解析流程，转而去加载解析并且执行 JS。这是因为浏览器并不知道 JS 执行是否会改变当前页面的 HTML 结构，如果 JS 代码里用了 document.write 方法来修改 html，之前的和 html 解析就没有任何意义了，这也就是为什么我们一直说要把 script 标签要放在合适的位置，或者使用 async 或 defer 属性来异步加载执行 JS。</p><h4 id="1-3-Layout-Tree"><a href="#1-3-Layout-Tree" class="headerlink" title="1.3 Layout Tree"></a>1.3 Layout Tree</h4><p>在 html 解析完成后，我们就会获得一个 DOM Tree（树），但我们还不知道 DOM Tree 上的每个节点应该长什么样子，主线程需要解析 CSS，并确定每个 DOM 节点的计算样式，即使你没有提供自定义的 CSS 样式，浏览器会有自己默认的样式表，比如 h2 的字体要比 h3 的大。在知道 DOM 结构和每个节点的样式后，我们接下来需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这个阶段被称为 layout 布局，主线程通过遍历 dom 和计算好的样式来生成 Layout Tree。Layout Tree 上的每个节点都记录了 x、y 坐标和边框尺寸。这需要注意的是 DOM Tree 和 Layout Tree 并不是一一对应的，设置了 display:none 的节点不会出现在 Layout Tree 上，而在 before 伪类中添加了 content 值的元素 content 中的内容会出现在 Layout Tree 上，不会出现在 DOM 树里，这是因为 DOM 是通过 HTML 解析获得的，并不关系样式，而 Layout Tree 是根据 DOM 和计算好的样式来生成，Layout Tree 是和最后展示在屏幕上节点是对应的。</p><h4 id="1-4-绘制（paint）"><a href="#1-4-绘制（paint）" class="headerlink" title="1.4 绘制（paint）"></a>1.4 绘制（paint）</h4><p>现在我们已经知道了元素的大小形状和位置，但还不知道以什么样的顺序绘制（paint）这个节点，例如 z-index 这个属性会影响节点绘制的层级关系，如果按照 dom 的层级结构来绘制页面则会导致错误的渲染。所以为了保证在屏幕上展示正确的层级，主线程遍历 Layout Tree 创建一个绘制记录表（Paint Record），该表记录了绘制的顺序，这个阶段配称为绘制（Paint）。</p><h4 id="1-5-栅格化"><a href="#1-5-栅格化" class="headerlink" title="1.5 栅格化"></a>1.5 栅格化</h4><p>现在知道了文档的绘制顺序，终于到了该把这些信息转化成像素点显示在屏幕上了，这个行为被称为栅格化（Rastering）。chrome 最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式带来的问题就是会导致展示延迟。现在 chrome 进行了优化升级，使用了一种更为复杂的栅格化流程叫做合成（compositing），合成是一种将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程（compositor Thread）中单独进行合成页面，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可。</p><h4 id="1-6-layer-tree"><a href="#1-6-layer-tree" class="headerlink" title="1.6 layer tree"></a>1.6 layer tree</h4><p>主线程遍历 Layout Tree 生成 layer tree，当 Layer Tree 生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块（tiles），然后将每个图块发送给栅格化线程（Raster Thread），栅格化线程栅格化每个图块，并将他们存储在 GPU 内存中，当图块栅格化完成后，合成器线程将收集成为 draw quads 的图块信息，这些信息里记录了图块在内存中的位置和在页面的那个位置绘制图块的信息，根据这些信息合成器线程生成一个合成器帧（Compositor Frame）然后合成器 Frame（帧）通过 IPC 传递给浏览器进程，接着浏览器进程将合成器帧传送到 GPU，然后 GPU 渲染展示到屏幕上。<br>当页面发生变化时，比如滚动了当前的页面，都会生成一个新的合成器帧，新的帧再传给 GPU，然后再次渲染到屏幕上。</p><h3 id="二、为什么栅格线程使用-GPU-计算而不是-CPU-计算？"><a href="#二、为什么栅格线程使用-GPU-计算而不是-CPU-计算？" class="headerlink" title="二、为什么栅格线程使用 GPU 计算而不是 CPU 计算？"></a>二、为什么栅格线程使用 GPU 计算而不是 CPU 计算？</h3><p><strong>CPU 与 GPU</strong>:CPU 和 GPU 作为计算机中最重要的两个计算单元直接决定了计算性能。<strong>CPU</strong>是计算机的大脑，负责处理各种不同的任务。在过去，大多数 CPU 是单芯片的，核心被安置在同一个芯片上。更新的 CPU 可以支持多核心，运算能力大大加强。而最新的的 cpu 已经达到 10 核心 20 线程数的能力了。<br><strong>GPU</strong>是另一个计算机的组成部分，与 CPU 不同，GPU 更擅长利用多核心同时处理单一的任务。像命名那样，GPU 最初被用于处理图像。这就是为什么使用 GPU 可以更快、更顺畅的渲染页面内容。随着 GPU 的发展，越来越多的计算任务也可以使用 GPU 来处理。甚至有人说 GPU 是人工智能的大功臣，可见 GPU 已经不再仅用于图像处理上了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、从获得-Html-到页面渲染的全部流程&quot;&gt;&lt;a href=&quot;#一、从获得-Html-到页面渲染的全部流程&quot; class=&quot;headerlink&quot; title=&quot;一、从获得 Html 到页面渲染的全部流程&quot;&gt;&lt;/a&gt;一、从获得 Html 到页面渲染的全部流程&lt;/
      
    
    </summary>
    
    
      <category term="chrome" scheme="https://umlink.github.io/categories/chrome/"/>
    
    
  </entry>
  
  <entry>
    <title>linux 查看文件大小</title>
    <link href="https://umlink.github.io/2021/03/25/look-file-size/"/>
    <id>https://umlink.github.io/2021/03/25/look-file-size/</id>
    <published>2021-03-25T01:31:57.000Z</published>
    <updated>2021-03-25T01:48:08.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令及说明"><a href="#命令及说明" class="headerlink" title="命令及说明"></a>命令及说明</h2><h4 id="查看整个磁盘大小"><a href="#查看整个磁盘大小" class="headerlink" title="查看整个磁盘大小"></a>查看整个磁盘大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br><span class="line">----------输出内容如下：</span><br><span class="line">devtmpfs        909M     0  909M    0% /dev</span><br><span class="line">tmpfs           919M   24K  919M    1% /dev/shm</span><br><span class="line">tmpfs           919M  456K  919M    1% /run</span><br><span class="line">tmpfs           919M     0  919M    0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1        50G  3.3G   44G    7% /</span><br><span class="line">tmpfs           184M     0  184M    0% /run/user/0</span><br></pre></td></tr></table></figure><h4 id="查看整个磁盘大小-1"><a href="#查看整个磁盘大小-1" class="headerlink" title="查看整个磁盘大小"></a>查看整个磁盘大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br><span class="line">----------输出内容如下：</span><br><span class="line">154Mbin</span><br><span class="line">4.0Ketc</span><br><span class="line">4.0Kgames</span><br><span class="line">14Minclude</span><br><span class="line">737Mlib</span><br><span class="line">182Mlib64</span><br><span class="line">61Mlibexec</span><br><span class="line">562M<span class="built_in">local</span></span><br><span class="line">52Msbin</span><br></pre></td></tr></table></figure><h4 id="查看指定文件大小"><a href="#查看指定文件大小" class="headerlink" title="查看指定文件大小"></a>查看指定文件大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du -sk share</span><br><span class="line">----------输出内容如下：</span><br><span class="line">358428share</span><br></pre></td></tr></table></figure><h4 id="查看前-10-文件大小列表"><a href="#查看前-10-文件大小列表" class="headerlink" title="查看前 10 文件大小列表"></a>查看前 10 文件大小列表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">du -s * | sort -nr | head</span><br><span class="line">----------输出内容如下：</span><br><span class="line">2234776usr</span><br><span class="line">933900var</span><br><span class="line">122176boot</span><br><span class="line">39632etc</span><br><span class="line">12884tmp</span><br><span class="line">448run</span><br><span class="line">148root</span><br><span class="line">16lost+found</span><br><span class="line">8opt</span><br><span class="line">4srv</span><br></pre></td></tr></table></figure><h4 id="查看文件个数"><a href="#查看文件个数" class="headerlink" title="查看文件个数"></a>查看文件个数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | wc -l</span><br></pre></td></tr></table></figure><h4 id="统计当前文件夹-目录-大小，并按文件大小排序"><a href="#统计当前文件夹-目录-大小，并按文件大小排序" class="headerlink" title="统计当前文件夹(目录)大小，并按文件大小排序"></a>统计当前文件夹(目录)大小，并按文件大小排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh * | sort -n</span><br></pre></td></tr></table></figure><h4 id="du-常用选项"><a href="#du-常用选项" class="headerlink" title="du 常用选项"></a>du 常用选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-h：以人类可读的方式显示</span><br><span class="line">-a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小</span><br><span class="line">-s：显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小</span><br><span class="line">-c：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和</span><br><span class="line">--apparent-size：显示目录或文件自身的大小</span><br><span class="line">-l ：统计硬链接占用磁盘空间的大小</span><br><span class="line">-L：统计符号链接所指向的文件占用的磁盘空间大小　　</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命令及说明&quot;&gt;&lt;a href=&quot;#命令及说明&quot; class=&quot;headerlink&quot; title=&quot;命令及说明&quot;&gt;&lt;/a&gt;命令及说明&lt;/h2&gt;&lt;h4 id=&quot;查看整个磁盘大小&quot;&gt;&lt;a href=&quot;#查看整个磁盘大小&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://umlink.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="linux" scheme="https://umlink.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>股票大作手回忆录</title>
    <link href="https://umlink.github.io/2020/01/21/stock-hand-recall/"/>
    <id>https://umlink.github.io/2020/01/21/stock-hand-recall/</id>
    <published>2020-01-21T07:30:25.000Z</published>
    <updated>2021-03-24T16:23:29.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-独立特行的少年赌客人"><a href="#第一章-独立特行的少年赌客人" class="headerlink" title="第一章 独立特行的少年赌客人"></a>第一章 独立特行的少年赌客人</h2><blockquote><p>在个㢟规律性波动中赚钱</p></blockquote><h2 id="第二章-独立特行的少年赌客人"><a href="#第二章-独立特行的少年赌客人" class="headerlink" title="第二章 独立特行的少年赌客人"></a>第二章 独立特行的少年赌客人</h2><blockquote><p>永远不要对时长生气</p></blockquote><h2 id="第三章-重返华尔街遭受重创"><a href="#第三章-重返华尔街遭受重创" class="headerlink" title="第三章 重返华尔街遭受重创"></a>第三章 重返华尔街遭受重创</h2><blockquote><p>适应股市，而不是让股市适应你</p></blockquote><h2 id="第四章-卧薪尝胆三反华尔街"><a href="#第四章-卧薪尝胆三反华尔街" class="headerlink" title="第四章 卧薪尝胆三反华尔街"></a>第四章 卧薪尝胆三反华尔街</h2><blockquote><p>找到正确的操作方法才能赚钱</p></blockquote><h2 id="第五章-“老火鸡”的至理名言"><a href="#第五章-“老火鸡”的至理名言" class="headerlink" title="第五章 “老火鸡”的至理名言"></a>第五章 “老火鸡”的至理名言</h2><blockquote><p>成功的秘诀再约预判大势和百信等待</p></blockquote><h2 id="第六章-最昂贵的一课"><a href="#第六章-最昂贵的一课" class="headerlink" title="第六章 最昂贵的一课"></a>第六章 最昂贵的一课</h2><blockquote><p>听信别人不如相信自己</p></blockquote><h2 id="第七章-老手怀特的故事"><a href="#第七章-老手怀特的故事" class="headerlink" title="第七章 老手怀特的故事"></a>第七章 老手怀特的故事</h2><blockquote><p>判断何时的出手时机（稳住，<code>涨</code>时试探性的买入，不要一味的找低谷买入）</p></blockquote><h2 id="第八章-再次破产后的绝地反击"><a href="#第八章-再次破产后的绝地反击" class="headerlink" title="第八章 再次破产后的绝地反击"></a>第八章 再次破产后的绝地反击</h2><blockquote><p>顺势而为，择机而动</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章-独立特行的少年赌客人&quot;&gt;&lt;a href=&quot;#第一章-独立特行的少年赌客人&quot; class=&quot;headerlink&quot; title=&quot;第一章 独立特行的少年赌客人&quot;&gt;&lt;/a&gt;第一章 独立特行的少年赌客人&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在个㢟规律性波动中
      
    
    </summary>
    
    
    
      <category term="股票" scheme="https://umlink.github.io/tags/%E8%82%A1%E7%A5%A8/"/>
    
  </entry>
  
  <entry>
    <title>小计浏览器缓存策略</title>
    <link href="https://umlink.github.io/2020/01/21/cache-control/"/>
    <id>https://umlink.github.io/2020/01/21/cache-control/</id>
    <published>2020-01-21T06:12:24.000Z</published>
    <updated>2021-03-24T16:23:29.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、强缓存"><a href="#一、强缓存" class="headerlink" title="一、强缓存"></a>一、强缓存</h2><blockquote><p>缓存未过期只取本地， 资源更新则GG。</p></blockquote><ul><li>Cache-Control <code>public, max-age=xxx</code></li><li>Expire</li></ul><h2 id="二、协商缓存"><a href="#二、协商缓存" class="headerlink" title="二、协商缓存"></a>二、协商缓存</h2><blockquote><p>每次都请求服务器？</p></blockquote><p>替换路径？</p><ul><li>hash <code>每次打包时生成的hash,不可用</code></li><li>chunkhash <code>单独chunk 的hash</code></li><li>contenthash <code>内容变化时的hash</code></li></ul><h2 id="三、ETag-amp-Last-Modified"><a href="#三、ETag-amp-Last-Modified" class="headerlink" title="三、ETag &amp; Last-Modified"></a>三、ETag &amp; Last-Modified</h2><ul><li>Nginx官方默认的ETag计算方式是为”文件最后修改时间16进制-文件长度16进制”。例：ETag： “59e72c84-2404”</li><li>Express框架使用了serve-static中间件来配置缓存方案，其中，使用了一个叫etag的npm包来实现etag计算</li><li>请求头带上了if-modified-since和if-none-match两个字段，则先判断etag，再判断last-modified</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、强缓存&quot;&gt;&lt;a href=&quot;#一、强缓存&quot; class=&quot;headerlink&quot; title=&quot;一、强缓存&quot;&gt;&lt;/a&gt;一、强缓存&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;缓存未过期只取本地， 资源更新则GG。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="浏览器" scheme="https://umlink.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="缓存" scheme="https://umlink.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
